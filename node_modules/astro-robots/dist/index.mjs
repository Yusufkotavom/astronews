import fs from 'fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import 'perf_hooks';

function validatePolicy(policy, logger) {
  if (policy.length === 0) {
    throwMsg("Policy array must contain at least one entry.", "error", logger);
  }
  policy.forEach((policy2, index) => {
    if (!policy2.userAgent) {
      throwMsg(`policy[${index}].userAgent is required.`, "error", logger);
    }
    if (!policy2.allow && !policy2.disallow || policy2.allow?.length === 0 && policy2.disallow?.length === 0) {
      throwMsg(
        `policy[${index}] must have at least one 'disallow' or 'allow' entry.`,
        "error",
        logger
      );
    }
    if (policy2.crawlDelay) {
      if (typeof policy2.crawlDelay !== "number" || policy2.crawlDelay < 0.1 || policy2.crawlDelay > 60) {
        throwMsg(
          `policy[${index}].crawlDelay must be between 0.1 and 60 seconds.`,
          "error",
          logger
        );
      }
    }
  });
}
function generatePolicyContent(policy) {
  return policy.map((rule) => {
    let content = `User-agent: ${Array.isArray(rule.userAgent) ? rule.userAgent.join("\nUser-agent: ") : rule.userAgent || "*"}
`;
    if (rule.allow) {
      const allowPaths = Array.isArray(rule.allow) ? rule.allow : [rule.allow];
      allowPaths.forEach((path2) => content += `Allow: ${path2}
`);
    }
    if (rule.disallow) {
      const disallowPaths = Array.isArray(rule.disallow) ? rule.disallow : [rule.disallow];
      disallowPaths.forEach(
        (path2) => content += `Disallow: ${path2}
`
      );
    }
    if (rule.crawlDelay)
      content += `Crawl-delay: ${rule.crawlDelay}
`;
    if (rule.cleanParam) {
      const cleanParams = Array.isArray(rule.cleanParam) ? rule.cleanParam : [rule.cleanParam];
      cleanParams.forEach(
        (param) => content += `Clean-param: ${param}
`
      );
    }
    return content;
  }).join("\n");
}
function validateSitemapUrl(url) {
  const urlPattern = /^(https?:\/\/)[^\s/$.?#].[^\s]*\.(xml|xml\.gz|txt|txt\.gz|json|xhtml)$/i;
  return urlPattern.test(url);
}
function generateSitemapContent(options, siteHref, logger) {
  if (!options.sitemap)
    return "";
  if (options.sitemap === true) {
    if (siteHref) {
      const defaultSitemap = `${siteHref}sitemap-index.xml`;
      return `Sitemap: ${defaultSitemap}`;
    } else {
      logger.warn(
        "`sitemap` is configured as true, but `AstroConfig.site` is not provided. Failed to generate default sitemap URL."
      );
      return "";
    }
  }
  const sitemaps = Array.isArray(options.sitemap) ? options.sitemap : [options.sitemap];
  const validSitemaps = sitemaps.filter((url) => {
    if (validateSitemapUrl(url)) {
      return true;
    } else {
      logger.warn(`\x1B[33mInvalid Sitemap URL: ${url}\x1B[33m`);
      return false;
    }
  });
  return validSitemaps.map((url) => `Sitemap: ${url}`).join("\n") + "\n";
}
function validateHost(host, logger) {
  const hostPattern = /^(?=.{1,253}$)(?:(?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63}$/;
  if (!hostPattern.test(host)) {
    throwMsg(
      "Host is invalid. It should be a valid domain like 'www.example.com'",
      "error",
      logger
    );
  }
}
function generateHostContent(options, logger) {
  if (options.host) {
    validateHost(options.host, logger);
    return `Host: ${options.host}
`;
  }
  return "";
}
function throwMsg(msg, type, logger) {
  const formattedMsg = {
    warn: () => logger.warn(`\x1B[33mWarning: ${msg}\x1B[0m`),
    error: () => {
      logger.error(`\x1B[31m${msg}\x1B[0m`);
      throw new Error(msg);
    }
  };
  formattedMsg[type]?.();
}
function generate(options, siteMapHref, logger) {
  if (!options.policy || options.policy.length === 0) {
    throwMsg("Policy configuration is required.", "error", logger);
  }
  validatePolicy(options.policy, logger);
  const content = [
    generatePolicyContent(options.policy),
    generateSitemapContent(options, siteMapHref, logger),
    generateHostContent(options, logger)
  ].join("\n");
  return content.trim();
}
function logInfo(fileSize, logger, destDir) {
  const sizeLimit = 10;
  if (fileSize > sizeLimit) {
    console.log(
      `
\x1B[42m\x1B[30m Generating 'robots.txt' file \x1B[39m\x1B[0m`
    );
    const warnMsg = [
      `\x1B[33m(!) 'robots.txt' file size is ${fileSize} KB.`,
      `- Keep it under ${sizeLimit} KB for best results.\x1B[0m
`
    ];
    console.log(warnMsg.join("\n"));
  }
  logger.info(
    `\`robots.txt\` (${fileSize}KB) created at \`${path.relative(process.cwd(), destDir)}\``
  );
}

function getFileSizeInKilobytes(fileBuffer) {
  return Buffer.byteLength(fileBuffer, "utf8") / 1024;
}

const defaults = {
  policy: [
    {
      userAgent: "*",
      allow: "/"
    }
  ],
  sitemap: true,
  host: null
};
function robots(options) {
  let config;
  let finalSiteMapHref;
  const filename = "robots.txt";
  const opts = { ...defaults, ...options };
  return {
    name: "astro-robots",
    hooks: {
      "astro:config:setup": ({ config: cfg }) => {
        config = cfg;
        if (config.site) {
          finalSiteMapHref = new URL(config.base, config.site).href;
        }
      },
      "astro:server:setup": ({ server, logger }) => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url?.startsWith(`/${filename}`)) {
            res.setHeader("Content-Type", "text/plain");
            res.setHeader("Cache-Control", "no-cache");
            res.end(generate(opts, finalSiteMapHref, logger));
          } else {
            next();
          }
        });
      },
      "astro:build:done": async ({ dir, logger }) => {
        const fileURL = new URL(filename, dir);
        const destDir = fileURLToPath(dir);
        const fileBuffer = generate(opts, finalSiteMapHref, logger);
        try {
          await fs.mkdir(destDir, { recursive: true });
          await fs.writeFile(fileURL, fileBuffer, "utf-8");
          throw "done";
        } catch (e) {
          if (e === "done") {
            const fileSize = getFileSizeInKilobytes(fileBuffer);
            logInfo(fileSize, logger, destDir);
          } else {
            throw e;
          }
        }
      }
    }
  };
}

export { robots as default };
